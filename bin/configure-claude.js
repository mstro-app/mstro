#!/usr/bin/env node
// Copyright (c) 2025-present Mstro, Inc. All rights reserved.
// Licensed under the MIT License. See LICENSE file for details.

/**
 * Mstro Claude Configuration Tool
 *
 * Automatically configures ~/.claude/settings.json and installs
 * the bouncer hook for Claude Code integration.
 *
 * Usage:
 *   npx mstro configure-hooks
 *   node bin/configure-claude.js
 */

import { chmodSync, existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { homedir } from 'node:os';
import { dirname, join, resolve } from 'node:path';
import { createInterface } from 'node:readline';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const MSTRO_ROOT = resolve(__dirname, '..');

const CLAUDE_DIR = join(homedir(), '.claude');
const CLAUDE_HOOKS_DIR = join(CLAUDE_DIR, 'hooks');
const CLAUDE_SETTINGS_FILE = join(CLAUDE_DIR, 'settings.json');
const _BOUNCER_HOOK_SOURCE = join(MSTRO_ROOT, 'hooks', 'bouncer.sh');
const BOUNCER_CLI_PATH = join(MSTRO_ROOT, 'server', 'mcp', 'bouncer-cli.ts');
const TSX_PATH = join(MSTRO_ROOT, 'node_modules', '.bin', 'tsx');

// ANSI colors
const colors = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
  dim: '\x1b[2m',
};

function log(msg, color = '') {
  console.log(`${color}${msg}${colors.reset}`);
}

function prompt(question) {
  const rl = createInterface({ input: process.stdin, output: process.stdout });
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.trim().toLowerCase());
    });
  });
}

/**
 * Generate the bouncer hook script with embedded paths
 * This ensures the hook knows where to find the bouncer CLI regardless of
 * how/where mstro was installed (npm global, npx, etc.)
 */
function generateBouncerHook(tsxPath, bouncerCliPath) {
  return `#!/usr/bin/env bash
#
# Mstro Bouncer Gate - Claude Code Hook
#
# This hook intercepts Claude Code tool calls and routes them through
# the Mstro bouncer for security analysis before execution.
#
# Generated by: npx mstro configure-hooks
# Dependencies: Node.js (no jq or bun required)
#

set -euo pipefail

# Paths configured at install time
TSX_PATH="${tsxPath}"
BOUNCER_CLI="${bouncerCliPath}"

# User-configurable settings
BOUNCER_TIMEOUT="\${BOUNCER_TIMEOUT:-10}"
BOUNCER_LOG="\${BOUNCER_LOG:-$HOME/.claude/logs/bouncer.log}"

# Ensure log directory exists
mkdir -p "$(dirname "$BOUNCER_LOG")"

# Read hook input from stdin
INPUT=$(cat)

# Run the bouncer via tsx (handles TypeScript execution)
if [ -x "$TSX_PATH" ] && [ -f "$BOUNCER_CLI" ]; then
  RESULT=$(echo "$INPUT" | timeout "$BOUNCER_TIMEOUT" "$TSX_PATH" "$BOUNCER_CLI" 2>> "$BOUNCER_LOG" || echo '{"decision": "allow", "reason": "Bouncer timeout or error"}')
  echo "$RESULT"
else
  # Fallback: use inline Node.js for basic pattern matching
  node --input-type=module -e "
const input = JSON.parse(process.argv[1]);
const toolName = input.tool_name || input.toolName || 'unknown';
const toolInput = input.input || input.toolInput || {};

// Quick allow for read-only operations
const readOnly = ['Read', 'Glob', 'Grep', 'Search', 'List', 'WebFetch', 'WebSearch'];
if (readOnly.includes(toolName)) {
  console.log(JSON.stringify({ decision: 'allow', reason: 'Read-only operation' }));
  process.exit(0);
}

// Build operation string
let op = toolName + ': ';
if (toolName === 'Bash') op += toolInput.command || '';
else if (['Write', 'Edit'].includes(toolName)) op += toolInput.file_path || toolInput.filePath || '';
else op += JSON.stringify(toolInput);

// Critical threat patterns
const threats = [
  [/rm\\s+-rf\\s+(\\/|~)(\\$|\\s)/, 'recursive delete of root/home'],
  [/:\\(\\)\\{.*\\}/, 'fork bomb'],
  [/dd\\s+if=\\/dev\\/zero\\s+of=\\/dev\\/sd/, 'disk overwrite'],
  [/mkfs\\s+\\/dev\\/sd/, 'filesystem format'],
];

for (const [pattern, reason] of threats) {
  if (pattern.test(op)) {
    console.log(JSON.stringify({ decision: 'deny', reason: 'Critical threat: ' + reason }));
    process.exit(0);
  }
}

console.log(JSON.stringify({ decision: 'allow', reason: 'Fallback: basic check passed' }));
" "$INPUT"
fi
`;
}

function ensureDirectories() {
  log('Step 1: Checking ~/.claude directory structure...', colors.bold);

  for (const dir of [CLAUDE_DIR, CLAUDE_HOOKS_DIR, join(CLAUDE_DIR, 'logs')]) {
    if (!existsSync(dir)) {
      log(`  Creating ${dir}`, colors.dim);
      mkdirSync(dir, { recursive: true });
    } else {
      log(`  ${dir} exists`, colors.green);
    }
  }

  log('  Done!\n', colors.green);
}

async function installBouncerHook(forceYes, isInteractive) {
  log('Step 2: Installing bouncer hook...', colors.bold);

  const hookDest = join(CLAUDE_HOOKS_DIR, 'bouncer.sh');
  const hookContent = generateBouncerHook(TSX_PATH, BOUNCER_CLI_PATH);
  const hookExists = existsSync(hookDest);

  if (hookExists) {
    log(`  Hook already exists at ${hookDest}`, colors.yellow);
    let overwrite = forceYes;

    if (!forceYes && isInteractive) {
      const answer = await prompt('  Overwrite existing hook? [y/N]: ');
      overwrite = answer === 'y' || answer === 'yes';
    }

    if (!overwrite) {
      log('  Skipping hook installation', colors.dim);
      log('  Done!\n', colors.green);
      return hookDest;
    }
  }

  writeFileSync(hookDest, hookContent);
  chmodSync(hookDest, 0o755);
  log(`  ${hookExists ? 'Overwrote' : 'Installed'} ${hookDest}`, colors.green);
  log('  Done!\n', colors.green);
  return hookDest;
}

function loadSettings() {
  if (!existsSync(CLAUDE_SETTINGS_FILE)) {
    return {};
  }
  try {
    const content = readFileSync(CLAUDE_SETTINGS_FILE, 'utf-8');
    const settings = JSON.parse(content);
    log(`  Loaded existing settings from ${CLAUDE_SETTINGS_FILE}`, colors.dim);
    return settings;
  } catch (err) {
    log(`  Warning: Could not parse existing settings.json: ${err.message}`, colors.yellow);
    log('  Will create new settings file', colors.dim);
    return {};
  }
}

async function configureSettings(hookDest, forceYes, isInteractive) {
  log('Step 3: Configuring settings.json...', colors.bold);

  const settings = loadSettings();
  if (!settings.hooks) {
    settings.hooks = {};
  }

  const bouncerHook = { type: 'command', command: hookDest, timeout: 10000 };
  const bouncerHookConfig = [
    { matcher: 'Bash', hooks: [bouncerHook] },
    { matcher: 'Write', hooks: [bouncerHook] },
    { matcher: 'Edit', hooks: [bouncerHook] }
  ];

  const existingPreToolUse = settings.hooks.PreToolUse;

  if (existingPreToolUse) {
    log('  Existing PreToolUse hook configuration found:', colors.yellow);
    log(`    ${JSON.stringify(existingPreToolUse, null, 2).split('\n').join('\n    ')}`, colors.dim);

    let update = forceYes;
    if (!forceYes && isInteractive) {
      const answer = await prompt('  Update PreToolUse hook to use Mstro bouncer? [y/N]: ');
      update = answer === 'y' || answer === 'yes';
    }

    if (!update) {
      log('  Keeping existing PreToolUse configuration', colors.dim);
    } else {
      settings.hooks.PreToolUse = bouncerHookConfig;
      log('  Updated PreToolUse hook configuration', colors.green);
    }
  } else {
    settings.hooks.PreToolUse = bouncerHookConfig;
    log('  Added PreToolUse hook configuration', colors.green);
  }

  const settingsContent = JSON.stringify(settings, null, 2);
  const settingsExists = existsSync(CLAUDE_SETTINGS_FILE);

  if (settingsExists) {
    const currentContent = readFileSync(CLAUDE_SETTINGS_FILE, 'utf-8');
    if (currentContent === settingsContent) {
      log('  No changes needed to settings.json', colors.dim);
    } else {
      const backupPath = `${CLAUDE_SETTINGS_FILE}.backup.${Date.now()}`;
      writeFileSync(backupPath, currentContent);
      log(`  Backed up existing settings to ${backupPath}`, colors.dim);
      writeFileSync(CLAUDE_SETTINGS_FILE, settingsContent);
      log(`  Updated ${CLAUDE_SETTINGS_FILE}`, colors.green);
    }
  } else {
    writeFileSync(CLAUDE_SETTINGS_FILE, settingsContent);
    log(`  Created ${CLAUDE_SETTINGS_FILE}`, colors.green);
  }

  log('  Done!\n', colors.green);
  return settingsContent;
}

function printSummary(hookDest, settingsContent) {
  log('=== Configuration Complete ===\n', colors.bold + colors.green);
  log('The following files have been configured:', colors.bold);
  log(`  ${CLAUDE_SETTINGS_FILE}`, colors.dim);
  log(`  ${hookDest}`, colors.dim);
  log('');
  log('Your settings.json now contains:', colors.bold);
  log(`${settingsContent.split('\n').map(l => `  ${l}`).join('\n')}`, colors.dim);
  log('');
  log('How the bouncer works:', colors.bold);
  log('');
  log('  Mstro sessions (headless): Full 2-layer security', colors.green);
  log('    Layer 1: Pattern matching (<5ms) - instant allow/deny for known operations', colors.dim);
  log('    Layer 2: AI analysis (~200-500ms) - context-aware review of ambiguous operations', colors.dim);
  log('');
  log('  Claude Code terminal REPL (claude): 1-layer security', colors.yellow);
  log('    Layer 1: Pattern matching only - blocks critical threats (fork bombs,', colors.dim);
  log('    destructive commands), allows everything else', colors.dim);
  log('    The AI analysis layer requires a running mstro server.', colors.dim);
  log('');
  log('To disable the bouncer hook, remove the PreToolUse entry from', colors.dim);
  log(`${CLAUDE_SETTINGS_FILE}`, colors.dim);
  log('');
}

async function main() {
  log('\n=== Mstro Claude Configuration ===\n', colors.bold + colors.blue);

  const isInteractive = process.stdin.isTTY;
  const forceYes = process.argv.includes('--yes') || process.argv.includes('-y');

  ensureDirectories();
  const hookDest = await installBouncerHook(forceYes, isInteractive);
  const settingsContent = await configureSettings(hookDest, forceYes, isInteractive);
  printSummary(hookDest, settingsContent);
}

main().catch((err) => {
  log(`\nError: ${err.message}`, colors.red);
  process.exit(1);
});
